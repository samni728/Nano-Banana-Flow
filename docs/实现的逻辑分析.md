# Gemini 去水印集成实现逻辑分析

## 1. 资源准备
需要从 `gemini-watermark-remover` 项目中提取以下文件并放入 `Nano-Banana-Flow`：
- **算法逻辑**: `src/core/alphaMap.js`, `src/core/blendModes.js`, `src/core/watermarkEngine.js`。
- **静态资源**: `src/assets/bg_48.png`, `src/assets/bg_96.png`。
- **适配**: 考虑到现有项目是纯 JS 环境，建议将这些算法模块整合到一个或几个单独的 JS 文件中供 `content.js` 引用。

## 2. 代码改造步骤

### 2.1 核心逻辑注入
将 `WatermarkEngine` 及其依赖项集成。可以考虑在 `manifest.json` 中将这些文件列入 `content_scripts`，或者直接合并进一个工具类。

### 2.2 下载拦截与处理 (content.js)
修改 `batchDownloadImagesFromList` 和 `handleGenerateImage` 之间的逻辑。

**伪代码逻辑：**
```javascript
async function processAndDownload(url, filename) {
    // 1. 获取图片数据
    const blob = await fetch(url).then(r => r.blob());
    
    // 2. 初始化引擎（需加载 bg_48/96.png）
    const engine = await WatermarkEngine.create();
    
    // 3. 处理图片
    const img = await loadImageFromBlob(blob);
    const canvas = await engine.removeWatermarkFromImage(img);
    
    // 4. 转为 Data URL 或 Blob 并发送下载指令
    const processedDataUrl = canvas.toDataURL('image/png');
    chrome.runtime.sendMessage({
        action: 'download_hq',
        url: processedDataUrl,
        filename: filename
    });
}
```

### 2.3 获取高清原图
继续保留目前项目的 `=s0` 策略，确保处理的是最高清的底图。

### 2.4 基础资源加载
由于 Chrome 扩展的限制，背景图 `bg_48.png` 等不能直接通过相对路径加载。需要：
1. 将图片放入 `icons/` 或 `images/` 目录。
2. 在 `manifest.json` 的 `web_accessible_resources` 中声明。
3. 使用 `chrome.runtime.getURL()` 获取完整路径。

## 3. 潜在风险与应对
- **Canvas 指纹干扰**: 用户若安装了指纹防护插件，`getImageData` 结果可能不准。需在文档中提醒或尝试检测。
- **内存占用**: 批量处理大图会消耗内存，需在 Canvas 使用完毕后及时销毁或清空相关变量。
- **跨域 (CORS)**: Gemini 的 `googleusercontent.com` 图片通常允许跨域，但如果遇到问题，需通过 `background.js` 代理 Fetch。

## 4. 验证计划
1. **自动化检测**: 使用多种尺寸的图片验证 `detectWatermarkConfig` 是否正确。
2. **视觉对比**: 对比去水印前后的图片，特别关注右下角是否有残留或过度修补。
3. **批量压力测试**: 连续生成 10+ 张图片，观察是否有内存溢出或进程卡死。
